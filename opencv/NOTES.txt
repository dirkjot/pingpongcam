

# General notes

#to use Ipython with cv2.imshow, use this:

import sys
sys.path.remove('/usr/local/lib/python2.7/dist-packages')
import cv2
import numpy as np
cv2.startWindowThread()
cv2.namedWindow('prev')


# cv2.imshow('prev', image)
# not waitKey necesssar!!!

# Isolate blue grid

#First convert to hsv. Note that gimp has hsv going up to 256, but cv2 has
#180 as the max value.  We still had to guess the right values, but we found
#them :-) 
#See also this excellent answer:
#http://stackoverflow.com/questions/17239253/opencv-bgr2hsv-creates-lots-of-artifacts


image = cv2.imread("/home/dpj/repos/pingpongcam/example/20170418_182807-800.jpg")
hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
threshold  = np.array([[100,0,0],[140,255,255]])
mask = cv2.inRange(hsv, threshold[0,:], threshold[1,:])
masked = cv2.bitwise_and(hsv, hsv, mask=mask)
blue = cv2.cvtColor(masked, cv2.COLOR_HSV2BGR)
del  masked
cv2.imshow('prev', blue)


# create white (blank) image 

blank = np.zeros(image.shape, np.uint8)
blank[:]=(255,255,255)


# mix blank and blue images according to mask

blankmasked =  cv2.bitwise_and(blank, blank, mask=cv2.bitwise_not(mask))
bluewhite = cv2.add(blue , blankmasked)


## actually doesn't need blank:

bluewhite = cv2.bitwise_or(blue, cv2.bitwise_not(np.stack(3* [mask], axis=2)))
cv2.imshow('prev', bluewhite)


# shape detection

#http://www.pyimagesearch.com/2016/02/08/opencv-shape-detection/

 In [8]: img = cv2.cvtColor(bluewhite, cv2.COLOR_BGR2GRAY)

 In [9]: img = cv2.GaussianBlur(img, (5,5), 0)


In [10]: img = cv2.threshold(img, 60, 255, cv2.THRESH_BINARY)[1]


 img = cv2.bitwise_not(img)  # contours expects white image on black bg


# destroys img if not copied
cnts = cv2.findContours(img.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[0]
# finds 7 contours in my img

# not exactly what I expected: 4 squares found but only 1 seems realistic
#In [29]: [ len(c) for c in cnts ]
#Out[29]: [29, 4, 50, 4, 4, 44, 2]


In [36]: for c in cnts:
   ....:     peri = cv2.arcLength(c, True)
   ....:     approx = cv2.approxPolyDP(c, 0.04 * peri, True)
   ....:     if len(approx) == 4:
   ....:         print approx
   ....:         
[[[526 316]]

 [[525 317]]

 [[527 319]]

 [[527 316]]]
[[[793 201]]

 [[793 206]]

 [[798 206]]

 [[798 201]]]
[[[793 153]]

 [[793 154]]

 [[798 154]]

 [[798 153]]]
[[[213 101]]

 [[216 300]]

 [[356 302]]

 [[357 106]]]

